## Формирование табеля
Вам дана таблица problem, в которой хранится:

* id - id задачи
* name - название задачи
* solution - решение задачи
* другие данные

Вам нужно написать запрос, который создаст заготовку табеля в формате «все месяцы - все задачи» (для каждого месяца
вывести каждую задачу).

Выведите:

* номер месяца
* id задачи

Пример:
```
code	problem
1	1
1	2
1	3
...	...
2	1
2	2
2	3
...	...
```

## Решение
```sql
SELECT
    months.month_code,
    problems.id
FROM
    (SELECT generate_series(1, 12) AS month_code) AS months
CROSS JOIN
    (SELECT DISTINCT id FROM problem) AS problems
ORDER BY
    months.month_code,
    problems.id;
```
- `generate_series(1, 12)` - генерирует последовательность чисел
- `CROSS JOIN` - создаёт все возможные комбинации между двумя наборами данных и соединяет каждый месяц с каждым id из problem

## Поиск вредоносного кода
Вам дана таблица CodeSubmit, в которой хранится информация:

user_id - какой пользователь
code - какой код отправил на проверку
created_at - в какое время это происходило
language_id - какой язык использовали
Иногда пользователи платформы любят «шалить» и пытаются сломать систему, отправив на проверку вредоносный код. Вам
нужно найти случаи таких атак:

Какой код написали
Какой язык использовали
Вывести нужно следующие нарушения:

в задачах, которые решались на SQL, есть команды drop, delete, truncate, insert, create. После них всегда идет пробел и минимум 1 символ. (DELETE FROM ClientBalance WHERE … FROM …)
в задачах, которые решались на Python, есть команды exec, eval. Будем считать, что после них может идти любой пробельный символ, а затем обязательно открывающаяся скобка и минимум 1 символ. Что перед этим и после - не так важно.

Примечание: Будьте осторожны с регистром букв.

Пример вредоносного кода на SQL:

`DROP users`
Пример вредоносного кода на Python:

`assert eval("os.system('rm -rf /')")`
Дополнительно тему поиска по шаблону можно изучить здесь: https://postgrespro.ru/docs/postgresql/9.6/functions-matching.

### Решение
```sql
SELECT code, 
       CASE 
           WHEN language_id = 1 THEN 'SQL'
           WHEN language_id = 2 THEN 'Python'
       END as language_id
FROM CodeSubmit
WHERE 
    (language_id = 1 AND 
     UPPER(code) LIKE '%DROP %' OR 
     UPPER(code) LIKE '%DELETE %' OR 
     UPPER(code) LIKE '%TRUNCATE %' OR 
     UPPER(code) LIKE '%INSERT %' OR 
     UPPER(code) LIKE '%CREATE %'
    )
    OR 
    (language_id = 2 AND 
     UPPER(code) LIKE '%EXEC(%' OR 
     UPPER(code) LIKE '%EVAL(%'
    );
```

## Сглаживание DAU

Вам дана таблица UserEntry в которой фиксируется первый заход пользователя на платформу за текущий день.

Таблица UserEntry содержит:

id - уникальный id каждого входа в формате int.
entry_at - время входа пользователя в формате timestamp.
page_id - id страницы, на которую зашел пользователь. Формат int.
user_id - id пользователя в формате int.
Ваша задача:

Посчитать DAU за каждый день 2022 года на основании заходов пользователей на платформу (почитать про DAU можно здесь https://www.unisender.com/ru/glossary/mau-dau-ili-osnovnye-metriki-mobilnyh-prilozhenij/)
Сделать столбец, где значения DAU будут сглажены с помощью метода скользящего среднего (https://antonz.ru/window-rolling/#rolling-avg)
Сделать столбец, где значения DAU будут сглажены с помощью метода медианного сглаживания (https://studfile.net/preview/9931880/page:5/)
В результате должны получиться столбцы:

ymd - столбец с днем (в текстовом формате)
cnt - значение DAU
sliding_average - сглаживание средним
sliding_median - сглаживание медианой
Примечание: При сглаживании берем все значения DAU за предыдущие даты. Текущую дату также включаем.

Примечание: При расчете медианы рассчитанное значение не обязано входить в исходный набор данных.

```sql
WITH DailyActiveUsers AS (
    SELECT
        to_char(entry_at, 'YYYY-MM-DD') AS ymd,
        COUNT(DISTINCT user_id) AS cnt
    FROM
        UserEntry
    WHERE
        entry_at >= '2022-01-01' AND entry_at < '2023-01-01'
    GROUP BY
        to_char(entry_at, 'YYYY-MM-DD')
),
SlidingAverages AS (
    SELECT
        ymd,
        cnt,
        AVG(cnt) OVER (ORDER BY ymd ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS sliding_average
    FROM
        DailyActiveUsers
),
SlidingMedians AS (
    SELECT
        ymd,
        cnt,
        sliding_average,
        (SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cnt) 
         FROM (SELECT cnt 
               FROM SlidingAverages 
               WHERE ymd <= sa.ymd) AS subquery) AS sliding_median
    FROM
        SlidingAverages sa
)
SELECT
    ymd,
    cnt,
    sliding_average,
    sliding_median
FROM
    SlidingMedians
ORDER BY
    ymd;
```

**Разбор этого SQL запроса**
### 1. WITH

Ключевое слово WITH используется для создания временных именованных подзапросов, которые можно использовать в основном запросе. Это похоже на создание временных таблиц, которые существуют только в рамках данного запроса. Это может помочь сделать запрос более организованным и читаемым.

### 2. to_char

Функция to_char используется для преобразования даты или времени в строку в заданном формате. В данном случае to_char(entry_at, 'YYYY-MM-DD') преобразует дату и время входа пользователя (entry_at) в строку формата "ГГГГ-ММ-ДД", что удобно для группировки по дням.

### 3. OVER (ORDER BY ymd ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)

Эта конструкция используется в аналитических функциях для определения набора строк, по которому будет выполняться вычисление. Давай разберем каждую часть:

- OVER: Указывает, что за ним следует аналитическая функция.
- ORDER BY ymd: Определяет порядок строк, по которому будет проводиться вычисление. В данном случае строки упорядочиваются по дате (ymd).
- ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: Определяет диапазон строк для вычисления функции. Здесь это значит, что функция будет применяться ко всем строкам от начала до текущей строки. Это важно для расчёта скользящего среднего, поскольку оно учитывает все предыдущие значения до текущей даты включительно.

### 4. PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cnt)

Эта конструкция используется для вычисления процентиля, который представляет собой значение, ниже которого находится определенный процент данных. В данном случае:

- PERCENTILE_CONT(0.5): Вычисляет медиану (50-й процентиль) для указанного набора данных.
- WITHIN GROUP (ORDER BY cnt): Указывает, как именно данные должны быть упорядочены перед вычислением процентиля. Здесь данные упорядочиваются по количеству уникальных пользователей (cnt) для каждой даты.

### Принцип построения запроса

1. Подзапрос DailyActiveUsers: Вычисляет количество уникальных пользователей (DAU) для каждого дня 2022 года и группирует данные по датам.

2. Подзапрос SlidingAverages: Использует результаты первого подзапроса для расчета скользящего среднего количества пользователей. Скользящее среднее вычисляется, включая все предыдущие дни вплоть до текущего.

3. Подзапрос SlidingMedians: Использует данные из второго подзапроса для вычисления медианного значения DAU, также включая все предыдущие дни.

4. Основной запрос: Извлекает данные из последнего подзапроса, выводя дату, количество уникальных пользователей, скользящее среднее и медиану.

Этот запрос помогает анализировать активность пользователей на платформе, сглаживая ежедневные данные, чтобы лучше понимать тренды и изменения во времени.