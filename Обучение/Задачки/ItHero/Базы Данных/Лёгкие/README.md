## Задание №1
Вам дана таблица users с полями:
username
email

Вам нужно проверить гипотезу, что пользователи часто делают username на платформе таким же, как левая часть почты (до символа @).

Напишите запрос, который выведет:

1. username
2. email
3. левую часть email
4. `isEqual` - столбец `True`/`False`, который проверяет гипотезу

Примечание: Обратите внимание, что myUSERname и myusername для почтовых сервисов — одно и
то же, т.к. они не чувствительны к регистру.
## Решение
```sql
SELECT
    username,
    email,
    SUBSTRING(email, 1, POSITION('@' IN email) - 1) AS left_part,
    CASE
        WHEN LOWER(username) = SUBSTRING(LOWER(email), 1, POSITION('@' IN email) - 1) THEN TRUE
        ELSE FALSE
    END AS isequal
FROM
    users;
```
___
## Задание №2
Процент скидок от суммы продаж

Вы работаете с базой данных apteka. Обязательно указывайте имя БД при указании таблиц. Apteka содержит следующие таблицы:

Bonuscheques

* дата и время совершения транзакции - datetime

* название аптеки - shop

* номер бонусной карты - card

* количество начисленных бонусов - bonus_earned

* количество потраченных бонусов - bonus_spent

* сумма чека - summ

* сумма чека с учетом скидок и списаний бонусов - summ_with_disc

* номер документа - doc_id

Shops

* идентификатор аптеки - id

* название аптеки - name

 

Задача

Чтобы понимать, что бонусная система не работает нам во вред, определите процент, который сумма скидок составляет от общей суммы продаж в каждой аптеке.

Столбцы в результате

shop - Аптека в формате "Аптека 7"
pct - процент, округленный до двух знаков после запятой

## Решение
```sql
SELECT 
    r.shop,
    ROUND(r.all_summ_skid / r.all_summ * 100, 2) AS pct
FROM (
    SELECT 
        b.shop,
        SUM(b.summ - b.summ_with_disc) * 1.0 AS all_summ_skid,
        SUM(b.summ) * 1.0 AS all_summ
    FROM 
        apteka.Bonuscheques b
    GROUP BY 
        b.shop
) r
```
## Решение №2 
#### *Это решение без вложенного запроса, меньше, но чуть с более сложной формулой*
Умножение на 1.0 нужно для приведения к типу float, так как в обратом случае вычисления будут не точными и не пройдёт тесты 1 и 2
```sql
SELECT
    b.shop,
    ROUND(SUM((b.summ * 1.0) - (b.summ_with_disc * 1.0)) / SUM(b.summ) * 100, 2) AS pct
FROM apteta.Bonuscheques b
GROUP BY b.shop
```

---

## Задача №3

Клиенты с количеством заказов выше среднего
Вы работаете с базой данных apteka. Обязательно указывайте имя БД при указании таблиц. Apteka содержит следующие таблицы:

Bonuscheques

* дата и время совершения транзакции - datetime

* название аптеки - shop

* номер бонусной карты - card

* количество начисленных бонусов - bonus_earned

* количество потраченных бонусов - bonus_spent

* сумма чека - summ

* сумма чека с учетом скидок и списаний бонусов - summ_with_disc

* номер документа - doc_id

 

Задача

Напишите запрос, который выводит карты клиентов, участвующих в бонусной программе и их количество заказов, при условии, что количество их заказов превышает среднее значение по всем пользователям бонусной программы.

Столбцы в результате

card - номер бонусной карты
order_count - количество заказов по этой карте

## Решение
```sql
WITH order_counts AS (
  SELECT 
    card, 
    COUNT(DISTINCT doc_id) AS order_count
  FROM 
    apteka.Bonuscheques
  WHERE 
    card IS NOT NULL
  GROUP BY 
    card
)
-- основной запрос
SELECT 
    card, order_count
FROM 
    order_counts
WHERE 
    order_count > (SELECT AVG(order_count) FROM order_counts)
ORDER BY 
    order_count DESC;
```
DESC сортирует результат по убыванию, можно его убрать (ASC), это не влияет на решение

## Задача №4

Среднее количество бонусов для аптеки
Вы работаете с базой данных apteka. Обязательно указывайте имя БД при указании таблиц. Apteka содержит следующие таблицы:

Bonuscheques

* дата и время совершения транзакции - datetime

* название аптеки - shop

* номер бонусной карты - card

* количество начисленных бонусов - bonus_earned

* количество потраченных бонусов - bonus_spent

* сумма чека - summ

* сумма чека с учетом скидок и списаний бонусов - summ_with_disc

* номер документа - doc_id

Shops

* идентификатор аптеки - id

* название аптеки - name

 

Задача

У вас есть таблица bonuscheques, которая содержит информацию о транзакциях по бонусной системе. Каждая запись в таблице представляет собой одну транзакцию, содержащую информацию о магазине, количестве начисленных бонусов и других данных.

Напишите запрос, который вычислит среднее количество начисленных бонусов для каждой аптеки. Результат округлите до двух знаков после запятой.

Столбцы в результате

shop - Аптека в формате "Аптека 7"
avg_bonus - среднее количество начисленных бонусов, округленное до двух знаков после запятой

## Решение
```sql
SELECT 
    a.shop,
    ROUND(AVG(a.bonus_earned), 2) AS bonus_avg
FROM 
    apteka.Bonuscheques a
GROUP BY 
    a.shop;
```

## Задача №5
### Та же БД, Суммарная стоимость заказов для каждой аптеки


Необходимо определить суммарную стоимость заказов для каждой аптеки, исключая заказы, у которых сумма чека со скидками и списаниями бонусов составляет менее 100.

Важно: рассматриваем только покупки клиентов, участвующих в бонусной системе, то есть заказы, хранящиеся в bonuscheques.

Примечание: В бонусной системе предполагаются скидки на покупку. В данном случае, стоимость заказа до применения скидки нас не интересует - это не полученная прибыль. Оперируйте суммой заказа после применения скидки.

Столбцы в результате

shop - Аптека в формате "Аптека 7"
total_sum - общая стоимость заказов по данной аптеке

## Решение
```sql
SELECT
  a.shop,
  SUM(summ_with_disc) AS total_sum
FROM 
    apteka.Bonuscheques a
WHERE 
    a.summ_with_disc >= 100 AND card IS NOT NULL 
GROUP BY 
    a.shop;
```

## Задача №6
Топ 3 сотрудника по количеству выполненных продаж
Вы работаете с базой данных apteka. Обязательно указывайте имя БД при указании таблиц. Apteka содержит следующие таблицы:

Sales

* дата покупки - dr_dat 

* время покупки - dr_tim

* номер чека - dr_nchk 

* номер магазина (FK - shops) - dr_apt 

* кол-во проданного товара - dr_kol

* закупочная цена - dr_czak

* розничная цена - dr_croz

* сумма скидки - dr_sdisc

* табельный номер сотрудника (FK - employee) - dr_tabempl

Employee

* табельный номер сотрудника - emp_tabn

* ФИО сотрудника - emp_fio



Задача

Необходимо определить топ 3 сотрудников, которые совершили наибольшее количество продаж.

Примечание: поскольку в таблице продаж по бонусной системе не фиксируется сотрудник, определять наибольшее количество продаж следует по таблице sales.

Столбцы в результате

emp_tabn - ID сотрудника
employee_name - ФИО сотрудника
sales_count - количество продаж

```sql
SELECT 
    e.emp_tabn,
    e.emp_fio AS employee_name,
    COUNT(*) AS sales_count
FROM apteka.Sales s
JOIN apteka.Employee e ON s.dr_tabempl = e.emp_tabn
GROUP BY 
    e.emp_tabn,
    e.emp_fio
ORDER BY sales_count DESC
LIMIT 3;
```
**Разбор кода по вопросам**
* Объясни почему ты используешь COUNT(*), JOIN... ON...
* Что это такое и почему ты сделал так?
* Почему ты не используешь переменную dr_kol? 
* Как ты определяешь топ 3 сотрудников которые совершили наибольшее количество продаж?

**Ответ**
1. COUNT(*) vs COUNT(s.dr_nchk):
- COUNT(*) считает все строки
- COUNT(s.dr_nchk) считает количество номеров чеков
- В данном случае оба варианта дадут одинаковый результат, так как номер чека (dr_nchk) не может быть NULL в таблице продаж
- COUNT(*) считается чуть быстрее, так как не требует проверки конкретного поля

2. JOIN ... ON:
- JOIN соединяет две таблицы (Sales и Employee)
- ON указывает условие соединения (dr_tabempl = emp_tabn)
- Это необходимо, чтобы получить ФИО сотрудника из таблицы Employee, имея только его табельный номер в таблице Sales

3. Почему не используется dr_kol:
- dr_kol показывает количество проданного товара в одной транзакции
- Задача требует посчитать количество продаж (транзакций), а не сумму проданных товаров
- Если бы требовалось узнать количество проданных товаров, тогда использовали бы SUM(dr_kol)

4. Определение топ-3:
- GROUP BY группирует все продажи по сотруднику
- ORDER BY sales_count DESC сортирует по убыванию количества продаж
- LIMIT 3 оставляет только первые 3 записи

**Ответ на вопрос, который может возникнуть из предыдущего ответа**
* Какие именно строки считает COUNT(*) И почему если она считает большее количество строк это эффективнее чем COUNT(dr_nchk)?

COUNT(*) считает все строки в результате JOIN, включая:
- Каждую транзакцию продажи (каждый чек)
- Не проверяет значения в столбцах
- Просто увеличивает счетчик на 1 для каждой найденной строки

COUNT(dr_nchk) считает:
- Только строки, где dr_nchk не NULL
- Должен проверить каждое значение dr_nchk на NULL
- Увеличивает счетчик только для не-NULL значений

Пример для наглядности:
Допустим у нас есть продажи:
```
dr_nchk    dr_tabempl
1          100
2          100
3          100
NULL       100
```
В этом случае:
- COUNT(*) вернет 4 (посчитал все строки)
- COUNT(dr_nchk) вернет 3 (пропустил строку с NULL)

COUNT(*) эффективнее потому что:
1. Не тратит время на проверку значений NULL
2. Не обращается к конкретному столбцу
3. Просто считает количество строк в результате

В нашем случае с продажами результат будет одинаковым, так как:
- Номер чека (dr_nchk) не может быть NULL (это обязательное поле)
- Каждая строка в таблице Sales это одна продажа
- JOIN с Employee не создаст дополнительных строк

Поэтому хоть COUNT(*) технически эффективнее, в данном конкретном случае разница в производительности будет минимальной. Использование COUNT(*) считается лучшей практикой, когда нужно посчитать просто количество строк.