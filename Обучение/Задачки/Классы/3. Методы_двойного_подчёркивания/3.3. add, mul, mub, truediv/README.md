# Методы двойного подчёркивания
Метод `__radd__` используется, когда объект класса находится в правой части оператора `+`. Другими словами, когда мы пишем `a + b`, где `a` - объект класса, а `b` - другой объект.

В этом случае Python сначала пытается вызвать метод `__add__` у объекта `a`. Но если объект `b` не знает, как сложить себя с объектом `a` (т.е. у него нет метода `__add__`), то Python вызывает метод `__radd__` у объекта `a`.

Метод `__radd__` должен возвращать результат сложения объекта `a` с объектом `b`, но уже в обратном порядке.

Пример:
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __radd__(self, other):
        return Vector(other.x + self.x, other.y + self.y)

v = Vector(2, 3)
result = 5 + v  # вызывает __radd__
print(result.x, result.y)  # выводит 7 8
```
В этом примере мы определяем класс `Vector` и реализуем методы `__add__` и `__radd__`. Когда мы пишем `5 + v`, Python вызывает метод `__radd__` у объекта `v`, который возвращает результат сложения `5` с `v`.

## **`__rmul__`**

Метод `__rmul__` используется, когда объект класса находится в правой части оператора `*`. Другими словами, когда мы пишем `a * b`, где `a` - объект класса, а `b` - другой объект.

В этом случае Python сначала пытается вызвать метод `__mul__` у объекта `a`. Но если объект `b` не знает, как умножить себя на объект `a` (т.е. у него нет метода `__mul__`), то Python вызывает метод `__rmul__` у объекта `a`.

Метод `__rmul__` должен возвращать результат умножения объекта `a` на объект `b`, но уже в обратном порядке.

методы `__radd__` и `__rmul__` позволяют нам определить поведение объектов класса при использовании операторов `+` и `*` в обратном порядке.
### Маленькое примечание
Они нужны, чтобы обеспечить поддержку операторов в объектах класса, даже если объект справа от оператора не знает, как выполнить операцию с объектом слева.

Они могут быть полезны, когда мы хотим, чтобы объекты класса могли участвовать в операциях с различными типами данных, включая числа, строки и другие объекты.

### !
Однако, если у нас нет конкретных потребностей в использовании методов __radd__ и __rmul__, то их можно не реализовывать.

В общем, методы __radd__ и __rmul__ могут быть полезны, но они также могут усложнить проект, если они не нужны.
### _________
* `__add__`: Этот метод вызывается, когда используется оператор `+`. Он должен возвращать результат сложения двух объектов.
* `__mul__`: Этот метод вызывается, когда используется оператор `*`. Он должен возвращать результат умножения двух объектов.
* `__sub__`: Этот метод вызывается, когда используется оператор `-`. Он должен возвращать результат вычитания двух объектов.
* `__truediv__`: Этот метод вызывается, когда используется оператор `/`. Он должен возвращать результат деления двух объектов.

Пример:
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

v1 = Vector(2, 3)
v2 = Vector(4, 5)

v3 = v1 + v2  # вызывает __add__
print(v3.x, v3.y)  # выводит 6 8

v4 = v1 * 2  # вызывает __mul__
print(v4.x, v4.y)  # выводит 4 6
```
В этом примере мы определяем класс `Vector` и реализуем методы `__add__` и `__mul__`. Когда мы используем операторы `+` и `*` с объектами класса `Vector`, Python вызывает соответствующие методы и возвращает результаты операций.
Эти методы реализуются с расчётом на то, чтобы обеспечить поддержку операторов в объектах класса. Это позволяет использовать объекты класса в операциях, что делает код более читабельным и удобным.

Например, вместо того, чтобы писать `v1 = Vector(2, 3)`; `v2 = Vector(4, 5)`; `v3 = Vector(v1.x + v2.x, v1.y + v2.y)`, 
вы можете написать `v1 = Vector(2, 3)`; `v2 = Vector(4, 5)`;` v3 = v1 + v2`. Это гораздо более читабельно и удобно.